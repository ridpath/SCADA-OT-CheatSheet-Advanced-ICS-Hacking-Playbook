#!/usr/bin/env python3
"""
Rockwell EtherNet/IP (CIP) Security Assessment Toolkit
Author: Ridpath

FOR AUTHORIZED SECURITY TESTING AND RESEARCH ONLY.
Use only on systems you own or have explicit written permission to test.

"""

import argparse
import logging
import sys
import json
import difflib
import socket
import struct
import time
import threading
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from colorama import init, Fore, Style

try:
    from pycomm3 import LogixDriver, CIPDriver, Services
    from pycomm3.exceptions import CommError, RequestError, PyCommError
except ImportError:
    print("ERROR: Required dependencies not installed. Run: pip install pycomm3 colorama")
    sys.exit(1)

# Initialize colorama for cross-platform color support
init(autoreset=True)

class SecurityLevel(Enum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3

@dataclass
class SecurityAssessment:
    level: SecurityLevel
    vulnerabilities: List[str]
    recommendations: List[str]

class EnhancedCIPExploiter:
    def __init__(self, target_ip: str, port: int = 44818, timeout: float = 10.0, 
                 max_retries: int = 3, security_level: SecurityLevel = SecurityLevel.MEDIUM):
        self.target_ip = target_ip
        self.port = port
        self.timeout = timeout
        self.max_retries = max_retries
        self.security_level = security_level
        self.driver = None
        self.tag_list_cache = None
        self.connection_stats = {
            'attempts': 0,
            'successes': 0,
            'failures': 0,
            'total_time': 0.0
        }
        self.setup_logging()
        
    def setup_logging(self):
        """Configure comprehensive logging with security context"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - CIP_SECURITY_TOOL - %(levelname)s - [%(threadName)s] - %(message)s',
            handlers=[
                logging.FileHandler('cip_security_assessment.log', encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger('EnhancedCIPExploiter')
    
    def safe_connect(self) -> Tuple[bool, Optional[str]]:
        """
        Enhanced connection with comprehensive error handling and retry logic
        
        Returns:
            Tuple of (success_status, error_message)
        """
        for attempt in range(self.max_retries):
            self.connection_stats['attempts'] += 1
            start_time = time.time()
            
            try:
                self.logger.info(f"Connection attempt {attempt + 1}/{self.max_retries} to {self.target_ip}:{self.port}")
                
                # Validate IP address format
                try:
                    socket.inet_aton(self.target_ip)
                except socket.error:
                    error_msg = f"Invalid IP address format: {self.target_ip}"
                    self.logger.error(error_msg)
                    return False, error_msg
                
                self.driver = LogixDriver(
                    self.target_ip, 
                    port=self.port, 
                    init_tags=False, 
                    timeout=self.timeout,
                    route_path=None
                )
                
                self.driver.open()
                
                if self.driver.connected:
                    connect_time = time.time() - start_time
                    self.connection_stats['successes'] += 1
                    self.connection_stats['total_time'] += connect_time
                    
                    try:
                        controller_info = self.driver.get_processor_info()
                        self.logger.info(f"Successfully connected to controller in {connect_time:.2f}s: {controller_info}")
                        return True, None
                    except Exception as e:
                        self.logger.warning(f"Connected but failed to get controller info: {e}")
                        return True, f"Connected but info retrieval failed: {e}"
                else:
                    error_msg = "Driver connection established but not connected state"
                    self.connection_stats['failures'] += 1
                    self.logger.error(error_msg)
                    
            except CommError as e:
                error_msg = f"Communication error during connection: {e}"
                self.connection_stats['failures'] += 1
                self.logger.error(error_msg)
                
            except RequestError as e:
                error_msg = f"Request error during connection: {e}"
                self.connection_stats['failures'] += 1
                self.logger.error(error_msg)
                
            except PyCommError as e:
                error_msg = f"PyComm library error during connection: {e}"
                self.connection_stats['failures'] += 1
                self.logger.error(error_msg)
                
            except socket.timeout:
                error_msg = f"Socket timeout during connection attempt {attempt + 1}"
                self.connection_stats['failures'] += 1
                self.logger.error(error_msg)
                
            except socket.error as e:
                error_msg = f"Socket error during connection: {e}"
                self.connection_stats['failures'] += 1
                self.logger.error(error_msg)
                
            except Exception as e:
                error_msg = f"Unexpected error during connection: {e}"
                self.connection_stats['failures'] += 1
                self.logger.error(error_msg, exc_info=True)
            
            # Exponential backoff before retry
            if attempt < self.max_retries - 1:
                sleep_time = (2 ** attempt) + 1
                self.logger.info(f"Retrying in {sleep_time}s...")
                time.sleep(sleep_time)
        
        final_error = f"All {self.max_retries} connection attempts failed"
        self.logger.error(final_error)
        return False, final_error
    
    def disconnect(self):
        """Enhanced safe disconnection with comprehensive cleanup"""
        if self.driver:
            try:
                if hasattr(self.driver, 'connected') and self.driver.connected:
                    self.driver.close()
                    self.logger.info("Successfully disconnected from controller")
                else:
                    self.logger.info("Controller was not connected")
            except Exception as e:
                self.logger.error(f"Error during disconnection: {e}")
            finally:
                self.driver = None
                self.tag_list_cache = None
    
    def get_controller_info(self) -> Dict[str, Any]:
        """Enhanced controller information retrieval with error handling"""
        info = {
            'status': 'error',
            'data': {},
            'error': None
        }
        
        try:
            if not self.driver or not self.driver.connected:
                info['error'] = "Not connected to controller"
                return info
            
            processor_info = self.driver.get_processor_info()
            info['data'] = {
                'product_name': processor_info.get('ProductName', 'Unknown'),
                'vendor': processor_info.get('Vendor', 'Unknown'),
                'device_type': processor_info.get('DeviceType', 'Unknown'),
                'revision': processor_info.get('Revision', 'Unknown'),
                'serial_number': processor_info.get('SerialNumber', 'Unknown'),
                'ip_address': self.target_ip,
                'status': 'operational'
            }
            info['status'] = 'success'
            self.logger.info("Controller information retrieved successfully")
            
        except Exception as e:
            error_msg = f"Failed to get controller info: {e}"
            info['error'] = error_msg
            self.logger.error(error_msg)
        
        return info
    
    def enumerate_tags(self, pattern: str = None, force_refresh: bool = False) -> Dict[str, Any]:
        """
        Enhanced tag enumeration with caching and pattern matching
        
        Args:
            pattern: Optional pattern to filter tags
            force_refresh: Force refresh of cached tag list
            
        Returns:
            Dictionary with status and tag data
        """
        result = {
            'status': 'error',
            'tags': [],
            'count': 0,
            'error': None
        }
        
        try:
            if force_refresh or self.tag_list_cache is None:
                self.logger.info("Refreshing tag list cache")
                self.tag_list_cache = self.driver.get_tag_list()
            
            filtered_tags = []
            for tag in self.tag_list_cache:
                tag_name = tag['tag_name']
                if pattern is None or pattern.lower() in tag_name.lower():
                    filtered_tags.append(tag_name)
            
            result['tags'] = filtered_tags
            result['count'] = len(filtered_tags)
            result['status'] = 'success'
            self.logger.info(f"Enumerated {len(filtered_tags)} tags")
            
        except Exception as e:
            error_msg = f"Tag enumeration failed: {e}"
            result['error'] = error_msg
            self.logger.error(error_msg)
        
        return result
    
    def validate_tag_existence(self, tag_name: str) -> Tuple[bool, Optional[str]]:
        """Enhanced tag validation with detailed error reporting"""
        if not tag_name or not isinstance(tag_name, str):
            return False, "Invalid tag name format"
        
        if len(tag_name) > 255:  # Reasonable upper limit for tag names
            return False, "Tag name exceeds maximum length"
        
        tag_result = self.enumerate_tags()
        if tag_result['status'] != 'success':
            return False, f"Tag enumeration failed: {tag_result.get('error', 'Unknown error')}"
        
        all_tags = [t['tag_name'] for t in self.tag_list_cache] if self.tag_list_cache else []
        
        if tag_name not in all_tags:
            return False, f"Tag '{tag_name}' not found in controller"
        
        return True, None
    
    def read_tag_robust(self, tag_name: str) -> Dict[str, Any]:
        """
        Enhanced tag reading with comprehensive error handling and validation
        
        Args:
            tag_name: Name of the tag to read
            
        Returns:
            Dictionary with read results and status
        """
        result = {
            'status': 'error',
            'tag': tag_name,
            'value': None,
            'timestamp': time.time(),
            'error': None
        }
        
        try:
            # Pre-validation
            is_valid, validation_error = self.validate_tag_existence(tag_name)
            if not is_valid:
                result['error'] = validation_error
                return result
            
            # Perform read operation
            read_result = self.driver.read(tag_name)
            
            if read_result and hasattr(read_result, 'value'):
                result['value'] = read_result.value
                result['status'] = 'success'
                self.logger.info(f"Successfully read tag '{tag_name}': {read_result.value}")
            else:
                result['error'] = "Read operation returned no data"
                self.logger.warning(f"Read operation for '{tag_name}' returned no data")
                
        except CommError as e:
            error_msg = f"Communication error reading tag '{tag_name}': {e}"
            result['error'] = error_msg
            self.logger.error(error_msg)
            
        except RequestError as e:
            error_msg = f"Request error reading tag '{tag_name}': {e}"
            result['error'] = error_msg
            self.logger.error(error_msg)
            
        except Exception as e:
            error_msg = f"Unexpected error reading tag '{tag_name}': {e}"
            result['error'] = error_msg
            self.logger.error(error_msg, exc_info=True)
        
        return result
    
    def write_tag_robust(self, tag_name: str, value: Any) -> Dict[str, Any]:
        """
        Enhanced tag writing with comprehensive validation and error handling
        
        Args:
            tag_name: Name of the tag to write
            value: Value to write
            
        Returns:
            Dictionary with write results and status
        """
        result = {
            'status': 'error',
            'tag': tag_name,
            'value_written': value,
            'timestamp': time.time(),
            'error': None
        }
        
        try:
            # Pre-validation
            is_valid, validation_error = self.validate_tag_existence(tag_name)
            if not is_valid:
                result['error'] = validation_error
                return result
            
            # Type validation and conversion
            processed_value = self._validate_and_convert_value(value)
            if processed_value is None:
                result['error'] = f"Invalid value type for writing: {type(value)}"
                return result
            
            # Perform write operation
            self.driver.write(tag_name, processed_value)
            
            # Optional: Verify write by reading back
            if self.security_level == SecurityLevel.HIGH:
                verify_result = self.read_tag_robust(tag_name)
                if verify_result['status'] == 'success':
                    result['verified_value'] = verify_result['value']
                    result['verification_status'] = 'success' if verify_result['value'] == processed_value else 'mismatch'
            
            result['status'] = 'success'
            self.logger.info(f"Successfully wrote value {processed_value} to tag '{tag_name}'")
            
        except CommError as e:
            error_msg = f"Communication error writing tag '{tag_name}': {e}"
            result['error'] = error_msg
            self.logger.error(error_msg)
            
        except RequestError as e:
            error_msg = f"Request error writing tag '{tag_name}': {e}"
            result['error'] = error_msg
            self.logger.error(error_msg)
            
        except Exception as e:
            error_msg = f"Unexpected error writing tag '{tag_name}': {e}"
            result['error'] = error_msg
            self.logger.error(error_msg, exc_info=True)
        
        return result
    
    def _validate_and_convert_value(self, value: Any) -> Any:
        """Validate and convert input values to appropriate types"""
        if isinstance(value, (int, float, bool, str)):
            return value
        
        if isinstance(value, str):
            # Try to convert string to appropriate type
            if value.lower() in ('true', 'false'):
                return value.lower() == 'true'
            try:
                return int(value)
            except ValueError:
                try:
                    return float(value)
                except ValueError:
                    return value  # Return as string
        
        self.logger.warning(f"Unsupported value type: {type(value)}")
        return None
    
    def controller_control(self, action: str) -> Dict[str, Any]:
        """
        Enhanced controller control with safety checks
        
        Args:
            action: 'run' or 'program'
            
        Returns:
            Dictionary with control results
        """
        result = {
            'status': 'error',
            'action': action,
            'timestamp': time.time(),
            'error': None
        }
        
        valid_actions = ['run', 'program']
        if action.lower() not in valid_actions:
            result['error'] = f"Invalid action. Must be one of: {valid_actions}"
            return result
        
        try:
            if action.lower() == 'run':
                self.driver.set_controller_mode('run')
                result['status'] = 'success'
                self.logger.info("Controller set to RUN mode")
            elif action.lower() == 'program':
                self.driver.set_controller_mode('program')
                result['status'] = 'success'
                self.logger.warning("Controller set to PROGRAM mode - process stopped")
                
        except Exception as e:
            error_msg = f"Controller control failed for action '{action}': {e}"
            result['error'] = error_msg
            self.logger.error(error_msg)
        
        return result
    
    def security_assessment(self) -> SecurityAssessment:
        """
        Perform comprehensive security assessment of the controller
        
        Returns:
            SecurityAssessment object with findings
        """
        vulnerabilities = []
        recommendations = []
        
        self.logger.info("Starting comprehensive security assessment")
        
        # Check connection security
        conn_info = self.get_controller_info()
        if conn_info['status'] == 'success':
            vulnerabilities.append("Controller information publicly accessible")
            recommendations.append("Implement network segmentation and firewall rules")
        
        # Check tag enumeration
        tag_result = self.enumerate_tags()
        if tag_result['status'] == 'success' and tag_result['count'] > 0:
            vulnerabilities.append("Tag enumeration possible without authentication")
            recommendations.append("Implement CIP authentication and authorization")
        
        # Check critical operations
        try:
            # Test if controller mode can be changed
            test_result = self.controller_control('run')
            if test_result['status'] == 'success':
                vulnerabilities.append("Controller mode change possible without proper authorization")
                recommendations.append("Implement strict access control for controller operations")
        except:
            pass  # Expected if not authorized
        
        # Assess based on findings
        if len(vulnerabilities) >= 3:
            level = SecurityLevel.HIGH
        elif len(vulnerabilities) >= 1:
            level = SecurityLevel.MEDIUM
        else:
            level = SecurityLevel.LOW
        
        return SecurityAssessment(level, vulnerabilities, recommendations)
    
    def buffer_overflow_test(self, tag_base: str = "TEST") -> Dict[str, Any]:
        """
        Test for potential buffer overflow vulnerabilities
        
        Args:
            tag_base: Base name for test tags
            
        Returns:
            Dictionary with test results
        """
        results = {
            'status': 'completed',
            'tests_performed': [],
            'vulnerabilities_found': [],
            'errors': []
        }
        
        test_cases = [
            # Very long tag names
            {"type": "long_tag", "value": "A" * 500},
            # Special characters in tag names
            {"type": "special_chars", "value": "../../etc/passwd"},
            # Format string attempts
            {"type": "format_string", "value": "%s%s%s%s%s%s%s"},
            # Integer overflow attempts
            {"type": "large_int", "value": 2**64},
            # Negative numbers where not expected
            {"type": "negative_int", "value": -1},
        ]
        
        for i, test_case in enumerate(test_cases):
            test_tag = f"{tag_base}_{test_case['type']}_{i}"
            
            try:
                # Try to write malformed data
                write_result = self.write_tag_robust(test_tag, test_case['value'])
                
                if write_result['status'] == 'success':
                    results['vulnerabilities_found'].append({
                        'test_type': test_case['type'],
                        'tag': test_tag,
                        'value': test_case['value'],
                        'description': f"Potential buffer overflow in {test_case['type']} handling"
                    })
                
                results['tests_performed'].append({
                    'test_type': test_case['type'],
                    'status': write_result['status'],
                    'error': write_result.get('error')
                })
                
            except Exception as e:
                results['errors'].append(f"Test {test_case['type']} failed: {e}")
        
        self.logger.info(f"Buffer overflow testing completed: {len(results['vulnerabilities_found'])} potential issues found")
        return results
    
    def stress_test_connection(self, duration: int = 30, threads: int = 5) -> Dict[str, Any]:
        """
        Perform stress testing on the controller connection
        
        Args:
            duration: Test duration in seconds
            threads: Number of concurrent threads
            
        Returns:
            Dictionary with stress test results
        """
        results = {
            'total_operations': 0,
            'successful_operations': 0,
            'failed_operations': 0,
            'average_response_time': 0.0,
            'thread_results': []
        }
        
        stop_event = threading.Event()
        thread_list = []
        
        def worker(thread_id):
            thread_results = {
                'thread_id': thread_id,
                'operations': 0,
                'successes': 0,
                'failures': 0,
                'response_times': []
            }
            
            while not stop_event.is_set():
                try:
                    start_time = time.time()
                    
                    # Perform a simple read operation
                    test_result = self.read_tag_robust("test_tag")
                    
                    response_time = time.time() - start_time
                    thread_results['response_times'].append(response_time)
                    thread_results['operations'] += 1
                    
                    if test_result['status'] == 'success':
                        thread_results['successes'] += 1
                    else:
                        thread_results['failures'] += 1
                        
                except Exception as e:
                    thread_results['failures'] += 1
                    thread_results['operations'] += 1
            
            results['thread_results'].append(thread_results)
        
        # Start worker threads
        for i in range(threads):
            thread = threading.Thread(target=worker, args=(i,), daemon=True)
            thread_list.append(thread)
            thread.start()
        
        # Run for specified duration
        time.sleep(duration)
        stop_event.set()
        
        # Wait for all threads to complete
        for thread in thread_list:
            thread.join(timeout=5)
        
        # Aggregate results
        for thread_result in results['thread_results']:
            results['total_operations'] += thread_result['operations']
            results['successful_operations'] += thread_result['successes']
            results['failed_operations'] += thread_result['failures']
            
            if thread_result['response_times']:
                avg_time = sum(thread_result['response_times']) / len(thread_result['response_times'])
                results['average_response_time'] += avg_time
        
        if results['thread_results']:
            results['average_response_time'] /= len(results['thread_results'])
        
        self.logger.info(f"Stress test completed: {results['successful_operations']}/{results['total_operations']} successful")
        return results

def main():
    """Enhanced main execution function with comprehensive error handling"""
    parser = argparse.ArgumentParser(
        description='Enhanced Rockwell CIP Security Assessment Toolkit - FOR AUTHORIZED TESTING ONLY',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
SECURITY WARNING:
This tool is designed for authorized security testing only.
Unauthorized use may violate laws and cause system damage.
Always obtain proper authorization before use.
        '''
    )
    
    # Global arguments
    parser.add_argument('--debug', action='store_true', help='Enable debug logging')
    parser.add_argument('--timeout', type=float, default=10.0, help='Connection timeout in seconds')
    parser.add_argument('--retries', type=int, default=3, help='Maximum connection retries')
    parser.add_argument('--security-level', choices=['low', 'medium', 'high'], 
                       default='medium', help='Security assessment level')
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Enhanced command definitions with additional security options
    commands = [
        ('info', 'Get controller information'),
        ('list-tags', 'List all controller tags'),
        ('read', 'Read tag value'),
        ('write', 'Write tag value'),
        ('control', 'Control controller mode'),
        ('recon', 'Comprehensive reconnaissance'),
        ('security-scan', 'Perform security assessment'),
        ('buffer-test', 'Test for buffer overflow vulnerabilities'),
        ('stress-test', 'Perform connection stress testing')
    ]
    
    for cmd, help_text in commands:
        cmd_parser = subparsers.add_parser(cmd, help=help_text)
        cmd_parser.add_argument('target', help='Target controller IP address')
        cmd_parser.add_argument('--port', type=int, default=44818, help='CIP port (default: 44818)')
        cmd_parser.add_argument('--json', action='store_true', help='Output in JSON format')
        cmd_parser.add_argument('--output', help='Save results to file')
        
        # Command-specific arguments
        if cmd == 'list-tags':
            cmd_parser.add_argument('--pattern', help='Filter tags by pattern')
        elif cmd == 'read':
            cmd_parser.add_argument('tag', help='Tag name to read')
        elif cmd == 'write':
            cmd_parser.add_argument('tag', help='Tag name to write')
            cmd_parser.add_argument('value', help='Value to write')
        elif cmd == 'control':
            cmd_parser.add_argument('action', choices=['run', 'program'], help='Controller mode')
        elif cmd == 'stress-test':
            cmd_parser.add_argument('--duration', type=int, default=30, help='Test duration in seconds')
            cmd_parser.add_argument('--threads', type=int, default=5, help='Number of concurrent threads')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    # Enhanced authorization warning
    print("\n" + "="*80)
    print(Fore.RED + "SECURITY ASSESSMENT TOOL - STRICT AUTHORIZATION REQUIRED" + Style.RESET_ALL)
    print("This tool is designed for authorized security testing and research purposes only.")
    print("Unauthorized use may cause system damage, process disruption, and legal consequences.")
    print("="*80 + "\n")
    
    try:
        # Convert security level
        security_level = SecurityLevel[args.security_level.upper()]
        
        # Initialize enhanced exploiter
        exploiter = EnhancedCIPExploiter(
            target_ip=args.target,
            port=args.port,
            timeout=args.timeout,
            max_retries=args.retries,
            security_level=security_level
        )
        
        # Establish connection
        success, error_msg = exploiter.safe_connect()
        if not success:
            print(Fore.RED + f"Connection failed: {error_msg}" + Style.RESET_ALL)
            return 1
        
        try:
            # Execute command
            if args.command == 'info':
                result = exploiter.get_controller_info()
                
            elif args.command == 'list-tags':
                result = exploiter.enumerate_tags(getattr(args, 'pattern', None))
                
            elif args.command == 'read':
                result = exploiter.read_tag_robust(args.tag)
                
            elif args.command == 'write':
                result = exploiter.write_tag_robust(args.tag, args.value)
                
            elif args.command == 'control':
                result = exploiter.controller_control(args.action)
                
            elif args.command == 'recon':
                # Comprehensive reconnaissance
                recon_data = {
                    'controller_info': exploiter.get_controller_info(),
                    'tags': exploiter.enumerate_tags(),
                    'security_assessment': exploiter.security_assessment()
                }
                result = {'status': 'success', 'data': recon_data}
                
            elif args.command == 'security-scan':
                result = exploiter.security_assessment()
                
            elif args.command == 'buffer-test':
                result = exploiter.buffer_overflow_test()
                
            elif args.command == 'stress-test':
                result = exploiter.stress_test_connection(
                    duration=getattr(args, 'duration', 30),
                    threads=getattr(args, 'threads', 5)
                )
            
            # Handle output
            if args.output:
                with open(args.output, 'w', encoding='utf-8') as f:
                    if hasattr(result, '__dict__'):
                        json.dump(result.__dict__, f, indent=2, default=str)
                    else:
                        json.dump(result, f, indent=2, default=str)
            
            if args.json:
                if hasattr(result, '__dict__'):
                    print(json.dumps(result.__dict__, indent=2, default=str))
                else:
                    print(json.dumps(result, indent=2, default=str))
            else:
                # Human-readable output
                if args.command == 'security-scan':
                    print(Fore.CYAN + "Security Assessment Results:" + Style.RESET_ALL)
                    print(f"Security Level: {result.level.name}")
                    print(f"Vulnerabilities Found: {len(result.vulnerabilities)}")
                    for vuln in result.vulnerabilities:
                        print(f"  - {vuln}")
                    print("Recommendations:")
                    for rec in result.recommendations:
                        print(f"  - {rec}")
                else:
                    print(Fore.GREEN + "Command executed successfully" + Style.RESET_ALL)
                    if isinstance(result, dict):
                        for key, value in result.items():
                            if key not in ['status', 'error'] and value is not None:
                                print(f"{key}: {value}")
            
            return 0
            
        except KeyboardInterrupt:
            print(Fore.YELLOW + "\nOperation interrupted by user" + Style.RESET_ALL)
            return 130
        except Exception as e:
            print(Fore.RED + f"Command execution failed: {e}" + Style.RESET_ALL)
            return 1
        finally:
            exploiter.disconnect()
            
    except Exception as e:
        print(Fore.RED + f"Tool initialization failed: {e}" + Style.RESET_ALL)
        return 1

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
